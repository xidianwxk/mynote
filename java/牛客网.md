##### 统计好元组

​     ==乘法原理==

+ 题目描述

  ```java
  链接：https://ac.nowcoder.com/acm/contest/10324/B
  来源：牛客网
  
  现在给定一个数组arr，和a,b两个数字，你要做的就是找到（i，j，k）。且满足 
      1. 0 <= i < j < k < arr.size()
      2. |arr[i] - arr[j]| <= a
      3. |arr[j] - arr[k]| <= b
  统计满足条件的个数并返回(最后结果可能很大，请取1000000007的余数)。
  ```

  

+ 题解

  ```java
  
  public class Solution {
  
      public static void main(String[] args) {
          int[] a = {7 , 1 , 8 , 9 , 0};
          int coun = countTriplets(a,3,3);
          System.out.println(coun);
      }
      public  static  int countTriplets (int[] arr, int a, int b) {
  
          int count = 0;
          int n = arr.length;
          int mod = 1000000007;
          for(int i = 1 ; i < n ; i++){
              int ij = 0 ;
              int jk = 0;
              for(int j = i - 1 ; j>= 0 ; j--){
                  if(Math.abs(arr[i] - arr[j]) <= a)
                      ij++;
              }
              for(int j = i + 1 ; j < n ; j++){
                  if(Math.abs(arr[i] - arr[j]) <= b)
                      jk++;
              }
              count += ij * jk;
              count %= mod;
          }
          return count;
      }
  }
  ```

  

##### 共鸣问题

+ 描述

  ```java
  链接：https://ac.nowcoder.com/acm/contest/10324/C
  来源：牛客网
  
  现在有n个音符和m对共鸣关系，编号为1~n，每个音符自己有一个奏响时的优美程度，共鸣关系(x,y,z)表示音符x和y同时奏响的额外优美程度是z，同时不奏响则为-z，其他情况为0。
  音符可以选择奏响或者不奏响，不奏响的音符没有优美程度。我们想知道最大的优美程度和是多少，我们不需要知道具体是哪些音符被奏响了，只需输出最大和即可。
  
  共鸣关系可能有重复，其共鸣效果也会重复叠加。
      
      2,1,[-10,-10],[[1,2,5]]
      =>   -5
  ```

  具体做法大概是：

  首先将答案减去给出的所有共鸣条件 (x,y,z)(*x*,*y*,*z*) 的权值 z*z*

  然后再让给出的共鸣条件的 a[x] += z*a*[*x*]+=*z* , a[y] += z*a*[*y*]+=*z*

  现在这个转化是没有问题的。

  因为你选择 a[x],a[y]*a*[*x*],*a*[*y*] 中的一个，相当于抵消掉了减去的 z*z* ,这时候获得的额外权值就是0

  倘若 a[x],a[y]*a*[*x*],*a*[*y*] 两个都不选，相当于最后获得的答案权值就是 -z−*z*

  倘若 a[x],a[y]*a*[*x*],*a*[*y*] 两个都选择，相当于最后获得的答案权值就是 z*z*

  那么这时候，我们就把问题转化了。现在就是问在当前的 a[]*a*[]序列中选出一些数使得和最大，允许不选，不选即和为0。

  然后简单贪心可以知道，我们只取 a[]*a*[] 序列中 大于 0 的即可（等于 0 的爱取不取）

+ 题解

  

  ```java
   public long wwork (int n, int m, int[] a, int[][] b) {
          // write code here
         long[] temp=new long[n];
         long ans=0;
          for (int i = 0; i < m; i++) {
              ans -=b[i][2];    //-5
              temp[b[i][0]-1] +=b[i][2];    //temp[0] = 5
              temp[b[i][1]-1] +=b[i][2];    //temp[1] = 5;
          }
          for(int i=0;i<n;i++){
              if(a[i]+temp[i]>0){     //    -10  +  5   <0   不选择
                  ans+=a[i]+temp[i];
              }
          }
          return ans;
      }
  ```



#####二分查找重复数组

+ 描述

  ```
  请实现有重复数字的有序数组的二分查找。
  输出在数组中第一个大于等于查找值的位置，如果数组中不存在这样的数，则输出数组长度加一。
  
  5,4,[1,2,4,4,5]
  =>  3
  ```

  

+ 题解

  ```java
      public int upper_bound_ (int n, int v, int[] a) {
          if(a[n-1]<v){return n+1;}//如果不存在这样的数：即数组中所有数字都比
          int Left = 0;
          int Right = n-1;
          while(Left < Right)
          {
              int Mid = Left+(Right-Left)/2;//防溢出
              if(a[Mid]>=v){Right = Mid;}
              else{Left = Mid+1;}
          }
          return Left+1;
      }
  ```

  

##### 递归二叉树三种遍历

+ 描述

  ```
  分别按照二叉树先序，中序和后序打印所有的节点。
  
  {1,2,3}
  [[1,2,3],[2,1,3],[2,3,1]]
  ```

  

+ 题解

  ```java
  import java.util.*;
  /*
   * public class TreeNode {
   *   int val = 0;
   *   TreeNode left = null;
   *   TreeNode right = null;
   * }
   */
  
  public class Solution {
      /**
       * 
       * @param root TreeNode类 the root of binary tree
       * @return int整型二维数组
       */
      List<Integer> front = new ArrayList<>();
      List<Integer> mid = new ArrayList<>();
      List<Integer> back = new ArrayList<>();
      
      public int[][] threeOrders (TreeNode root) {
          // write code here
          PreorderTraversal(root);
          InorderTraversal(root);
          PostorderTraversal(root);
          
          int[][] res = {
              front.stream().mapToInt(Integer::valueOf).toArray(),
              mid.stream().mapToInt(Integer::valueOf).toArray(),
              back.stream().mapToInt(Integer::valueOf).toArray()
          };
          
          return res;
      }
      
      //前序遍历
      public void PreorderTraversal(TreeNode root){
          if(root == null)
              return;
          front.add(root.val);
          PreorderTraversal(root.left);
          PreorderTraversal(root.right);
      }
      
      //中序遍历
      public void InorderTraversal(TreeNode root){
          if(root == null)
              return;
          InorderTraversal(root.left);
          mid.add(root.val);
          InorderTraversal(root.right);
      }
      
      //后序遍历
      public void PostorderTraversal(TreeNode root){
          if(root == null)
              return;
          PostorderTraversal(root.left);
          PostorderTraversal(root.right);
          back.add(root.val);
      }
  
  }
  ```

  